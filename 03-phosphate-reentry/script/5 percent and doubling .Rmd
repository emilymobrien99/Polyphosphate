---
title: "measuring doubling and 5% ScCg"
output: html_document
date: "2026-01-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)

# Load your data
# Expected format: CSV with 'Time' column and well columns (e.g., 'A1', 'A2', etc.)
# Adjust the file path to your data file
df <- read.csv("./20260114-KL,Ca-reentry.csv ", stringsAsFactors = FALSE)

# Function to convert H:MM:SS or HH:MM:SS to decimal hours
convert_time_to_hours <- function(time_str) {
  parts <- strsplit(time_str, ":")[[1]]
  hours <- as.numeric(parts[1])
  minutes <- as.numeric(parts[2])
  seconds <- as.numeric(parts[3])
  return(hours + minutes/60 + seconds/3600)
}

# Convert Time column from H:MM:SS format to decimal hours
df$Time <- sapply(df$Time, convert_time_to_hours)
time <- df$Time

# Get well column names (all columns except 'Time')
all_wells <- setdiff(names(df), 'Time')

# Filter to only wells B-G, columns 2-5 and 7-10
rows_to_include <- c('B', 'C', 'D', 'E', 'F', 'G')
cols_to_include <- c(2, 3, 4, 5, 7, 8, 9, 10)

well_columns <- c()
for (row in rows_to_include) {
  for (col in cols_to_include) {
    well_name <- paste0(row, col)
    if (well_name %in% all_wells) {
      well_columns <- c(well_columns, well_name)
    }
  }
}

cat("Analyzing", length(well_columns), "wells:", paste(well_columns, collapse = ", "), "\n")

# Convert all well columns to numeric
for (col in well_columns) {
  df[[col]] <- as.numeric(as.character(df[[col]]))
}

cat("Time range:", min(time), "to", max(time), "hours\n")

# Calculate background from control wells B6
control_wells <- c("B6")
background_values <- c()

for (well in control_wells) {
  if (well %in% names(df)) {
    # Get mean OD for this control well
    mean_od <- mean(df[[well]], na.rm = TRUE)
    background_values <- c(background_values, mean_od)
  }
}

# Calculate average background
if (length(background_values) > 0) {
  background <- mean(background_values)
  cat("Background (average of", paste(control_wells, collapse = ", "), "):", background, "\n")
} else {
  background <- 0
  cat("Warning: Control wells not found. Using background = 0\n")
}

# Initialize results dataframe
results <- data.frame(
  Well = character(),
  Max_Growth = numeric(),
  Doubling_Time = numeric(),
  stringsAsFactors = FALSE
)

# List to store plots
plot_list <- list()
```

This code runs doubling of OD using 30 minutes as the start time and includes background subraction
```{r}
# Analyze each well
for (well in well_columns) {
  od_data <- df[[well]]
  
  tryCatch({
    # Check if there's actual growth in this well
    growth_range <- max(od_data, na.rm = TRUE) - min(od_data, na.rm = TRUE)
    
    if (growth_range < 0.01) {
      stop(paste("Insufficient growth detected (range =", round(growth_range, 4), ")"))
    }
    
    # Use LOESS smoothing to create a smooth version of the data
    # span controls how smooth (0.1 = less smooth, follows data closely; 0.5 = more smooth)
    loess_fit <- loess(od_data ~ time, span = 0.3)
    
    # Generate smoothed curve
    time_fine <- seq(min(time), max(time), length.out = 500)
    od_smooth <- predict(loess_fit, newdata = time_fine)
    
    # Find maximum growth from smoothed curve
    K <- max(od_smooth, na.rm = TRUE)
    
    # Calculate doubling time from 30 minute baseline with background subtraction
    time_baseline <- 0.5  # 30 minutes in hours
    idx_baseline <- which.min(abs(time_fine - time_baseline))
    od_baseline <- od_smooth[idx_baseline]
    
    # Print the baseline OD values for this well
cat("Well", well, "- od_baseline:", round(od_baseline, 4), 
    "| After background subtraction:", round(od_baseline_corrected, 4), "\n")
    
    # Subtract background from baseline OD
    od_baseline_corrected <- od_baseline - background
    
    # Set doubling threshold (double the background-corrected baseline, then add background back)
    threshold <- (od_baseline_corrected * 2) + background
    
    # Find when it reaches double
    idx_double <- which(od_smooth >= threshold)[1]
    if (!is.na(idx_double) && od_baseline_corrected > 0) {
      time_double <- time_fine[idx_double]
      doubling_time <- time_double - time_baseline
    } else {
      time_double <- NA
      doubling_time <- NA
      if (od_baseline_corrected <= 0) {
        message(paste("Well", well, "- baseline OD after background subtraction is <=0"))
      }
    }
    
    # Store results
    results <- rbind(results, data.frame(
      Well = well,
      Max_Growth = K,
      Doubling_Time = doubling_time
    ))
    
    # Create plot data
    plot_data <- data.frame(Time = time, OD = od_data)
    smooth_data <- data.frame(Time = time_fine, OD = od_smooth)
    
    # Create plot
    p <- ggplot() +
      geom_point(data = plot_data, aes(x = Time, y = OD), alpha = 0.5, size = 2) +
      geom_line(data = smooth_data, aes(x = Time, y = OD), color = 'red', size = 1) +
      labs(title = paste0(well, '\nMax: ', round(K, 3), ', Doubling Time: ', round(doubling_time, 2), 'h'),
           x = 'Time (hours)', y = 'OD') +
      theme_bw()
    
    # Add doubling threshold lines if applicable
    if (!is.na(time_double)) {
      p <- p + 
        geom_hline(yintercept = threshold, linetype = 'dashed', color = 'green', alpha = 0.7) +
        geom_vline(xintercept = time_double, linetype = 'dashed', color = 'green', alpha = 0.7) +
        geom_point(aes(x = time_double, y = threshold), color = 'green', size = 3)
    }
    
    plot_list[[well]] <- p
    
  }, error = function(e) {
    message(paste("Could not analyze well", well, ":", e$message))
    results <<- rbind(results, data.frame(
      Well = well,
      Max_Growth = NA,
      Doubling_Time = NA
    ))
  })
}

# Arrange plots in grid
n_plots <- length(plot_list)
n_cols <- 4
n_rows <- ceiling(n_plots / n_cols)

# For large numbers of wells (like 96-well plates), save as PDF instead
# PDF doesn't have the same size restrictions as PNG
pdf('growth_curves_fitted_30d_bg.pdf', width = 16, height = 4 * n_rows)
do.call(grid.arrange, c(plot_list, ncol = n_cols))
dev.off()


# Sort results by well name
results <- results %>% arrange(Well)

# Print results
cat("\n", rep("=", 70), "\n", sep = "")
cat("GROWTH CURVE ANALYSIS 30d_bg RESULTS\n")
cat(rep("=", 70), "\n", sep = "")
print(results, row.names = FALSE)
cat(rep("=", 70), "\n", sep = "")

# Save results to CSV
write.csv(results, 'growth_analysis_results30d_bg.csv', row.names = FALSE)
cat("\nResults saved to 'growth_analysis_results30d_bg.csv'\n")
```

This code runs doubling starting at 30 minutes without backgroun subraction

```{r}
# Analyze each well
for (well in well_columns) {
  od_data <- df[[well]]
  
  tryCatch({
    # Check if there's actual growth in this well
    growth_range <- max(od_data, na.rm = TRUE) - min(od_data, na.rm = TRUE)
    
    if (growth_range < 0.01) {
      stop(paste("Insufficient growth detected (range =", round(growth_range, 4), ")"))
    }
    
    # Use LOESS smoothing to create a smooth version of the data
    # span controls how smooth (0.1 = less smooth, follows data closely; 0.5 = more smooth)
    loess_fit <- loess(od_data ~ time, span = 0.3)
    
    # Generate smoothed curve
    time_fine <- seq(min(time), max(time), length.out = 500)
    od_smooth <- predict(loess_fit, newdata = time_fine)
    
    # Find maximum growth from smoothed curve
    K <- max(od_smooth, na.rm = TRUE)
    
    # Calculate doubling time from 30 minute baseline
    time_baseline <- 0.5  # 30 minutes in hours
    idx_baseline <- which.min(abs(time_fine - time_baseline))
    od_baseline <- od_smooth[idx_baseline]
    
    # Set doubling threshold from that point
    threshold <- od_baseline * 2
    
    # Find when it reaches double
    idx_double <- which(od_smooth >= threshold)[1]
    if (!is.na(idx_double)) {
      time_double <- time_fine[idx_double]
      doubling_time <- time_double - time_baseline
    } else {
      time_double <- NA
      doubling_time <- NA
    }
    
    # Store results
    results <- rbind(results, data.frame(
      Well = well,
      Max_Growth = K,
      Doubling_Time = doubling_time
    ))
    
    # Create plot data
    plot_data <- data.frame(Time = time, OD = od_data)
    smooth_data <- data.frame(Time = time_fine, OD = od_smooth)
    
    # Create plot
    p <- ggplot() +
      geom_point(data = plot_data, aes(x = Time, y = OD), alpha = 0.5, size = 2) +
      geom_line(data = smooth_data, aes(x = Time, y = OD), color = 'red', size = 1) +
      labs(title = paste0(well, '\nMax: ', round(K, 3), ', Doubling Time: ', round(doubling_time, 2), 'h'),
           x = 'Time (hours)', y = 'OD') +
      theme_bw()
    
    # Add doubling threshold lines if applicable
    if (!is.na(time_double)) {
      p <- p + 
        geom_hline(yintercept = threshold, linetype = 'dashed', color = 'green', alpha = 0.7) +
        geom_vline(xintercept = time_double, linetype = 'dashed', color = 'green', alpha = 0.7) +
        geom_point(aes(x = time_double, y = threshold), color = 'green', size = 3)
    }
    
    plot_list[[well]] <- p
    
  }, error = function(e) {
    message(paste("Could not analyze well", well, ":", e$message))
    results <<- rbind(results, data.frame(
      Well = well,
      Max_Growth = NA,
      Doubling_Time = NA
    ))
  })
}

# Arrange plots in grid
n_plots <- length(plot_list)
n_cols <- 4
n_rows <- ceiling(n_plots / n_cols)

# For large numbers of wells (like 96-well plates), save as PDF instead
# PDF doesn't have the same size restrictions as PNG
pdf('growth_curves_fitted_30d.pdf', width = 16, height = 4 * n_rows)
do.call(grid.arrange, c(plot_list, ncol = n_cols))
dev.off()


# Sort results by well name
results <- results %>% arrange(Well)

# Print results
cat("\n", rep("=", 70), "\n", sep = "")
cat("GROWTH CURVE ANALYSIS 30d RESULTS\n")
cat(rep("=", 70), "\n", sep = "")
print(results, row.names = FALSE)
cat(rep("=", 70), "\n", sep = "")

# Save results to CSV
write.csv(results, 'growth_analysis_results_30d.csv', row.names = FALSE)
cat("\nResults saved to 'growth_analysis_results30d.csv'\n")
```


This will graph doubling data
```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)

# Load the results from the growth curve analysis
#results <- read.csv('growth_analysis_results_30d.csv', stringsAsFactors = FALSE)
results <- read.csv('growth_analysis_results30d_bg.csv', stringsAsFactors = FALSE)
# Extract row letter and column number from well names
results$Row <- substr(results$Well, 1, 1)
results$Column <- as.numeric(substr(results$Well, 2, nchar(results$Well)))

# Assign species based on column number
results$Species <- ifelse(results$Column %in% c(2, 3, 4, 5), "Species 1", "Species 2")

# Assign time point based on row
results$TimePoint <- case_when(
  results$Row == "B" ~ 6,
  results$Row == "C" ~ 4,
  results$Row == "D" ~ 3,
  results$Row == "E" ~ 2,
  results$Row == "F" ~ 1,
  results$Row == "G" ~ 0.5,
  TRUE ~ NA_real_
)

# Calculate mean for each species at each time point
summary_stats <- results %>%
  group_by(Species, TimePoint) %>%
  summarise(
    Mean_MaxGrowth = mean(Max_Growth, na.rm = TRUE),
    Mean_DoublingTime = mean(Doubling_Time, na.rm = TRUE),
    .groups = 'drop'
  )

# Create separate datasets for each species
species1_data <- results %>% filter(Species == "Species 1")
species2_data <- results %>% filter(Species == "Species 2")
species1_summary <- summary_stats %>% filter(Species == "Species 1")
species2_summary <- summary_stats %>% filter(Species == "Species 2")

# Bar graphs for Maximum Growth - Species 1
p1_species1 <- ggplot() +
  geom_bar(data = species1_summary, aes(x = factor(TimePoint), y = Mean_MaxGrowth),
           stat = "identity", fill = "steelblue", alpha = 0.7, width = 0.6) +
  geom_point(data = species1_data, aes(x = factor(TimePoint), y = Max_Growth),
             size = 3, position = position_jitter(width = 0.1, seed = 42)) +
  labs(title = "S. cerevisiae - Maximum Growth",
       x = "Time Point (hours)",
       y = "Maximum Growth (OD)") +
  theme_bw() +
  theme(text = element_text(size = 12))

# Bar graphs for Maximum Growth - Species 2
p1_species2 <- ggplot() +
  geom_bar(data = species2_summary, aes(x = factor(TimePoint), y = Mean_MaxGrowth),
           stat = "identity", fill = "coral", alpha = 0.7, width = 0.6) +
  geom_point(data = species2_data, aes(x = factor(TimePoint), y = Max_Growth),
             size = 3, position = position_jitter(width = 0.1, seed = 42)) +
  labs(title = "C. glabrata - Maximum Growth",
       x = "Time Point (hours)",
       y = "Maximum Growth (OD)") +
  theme_bw() +
  theme(text = element_text(size = 12))

# Bar graphs for Doubling Time - Species 1
p2_species1 <- ggplot() +
  geom_bar(data = species1_summary, aes(x = factor(TimePoint), y = Mean_DoublingTime),
           stat = "identity", fill = "steelblue", alpha = 0.7, width = 0.6) +
  geom_point(data = species1_data, aes(x = factor(TimePoint), y = Doubling_Time),
             size = 3, position = position_jitter(width = 0.1, seed = 42)) +
  labs(title = "K. lactis - Doubling Time",
       x = "Time Point (hours)",
       y = "Doubling Time (hours)") +
  theme_bw() +
  theme(text = element_text(size = 12))

# Bar graphs for Doubling Time - Species 2
p2_species2 <- ggplot() +
  geom_bar(data = species2_summary, aes(x = factor(TimePoint), y = Mean_DoublingTime),
           stat = "identity", fill = "coral", alpha = 0.7, width = 0.6) +
  geom_point(data = species2_data, aes(x = factor(TimePoint), y = Doubling_Time),
             size = 3, position = position_jitter(width = 0.1, seed = 42)) +
  labs(title = "C. albicans - Doubling Time",
       x = "Time Point (hours)",
       y = "Doubling Time (hours)") +
  theme_bw() +
  theme(text = element_text(size = 12))

# Display plots side by side
grid.arrange(p1_species1, p1_species2, ncol = 2)
grid.arrange(p2_species1, p2_species2, ncol = 2)

# Save combined plots
png("max_growth_comparisonklca.png", width = 14, height = 6, units = "in", res = 300)
grid.arrange(p1_species1, p1_species2, ncol = 2)
dev.off()

png("doubling_time_comparisonklca.png", width = 14, height = 6, units = "in", res = 300)
grid.arrange(p2_species1, p2_species2, ncol = 2)
dev.off()

# Print summary statistics
cat("\n=== SUMMARY STATISTICS ===\n")
print(summary_stats)

# Save summary statistics
write.csv(summary_stats, 'species_summary_stats.csv', row.names = FALSE)
cat("\nSummary statistics saved to 'species_summary_stats.csv'\n")
cat("Plots saved as 'max_growth_comparison.png' and 'doubling_timeklca_comparison.png'\n")
```

This code will calculate 5% of Max

```{r}
#install.packages("gridExtra")

library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)

# Load your data
# Expected format: CSV with 'Time' column and well columns (e.g., 'A1', 'A2', etc.)
# Adjust the filepath to your data file
df <- read.csv("./20260116Sc,Cg-reentry.csv", stringsAsFactors = FALSE)

# Function to convert H:MM:SS or HH:MM:SS to decimal hours
convert_time_to_hours <- function(time_str) {
  parts <- strsplit(time_str, ":")[[1]]
  hours <- as.numeric(parts[1])
  minutes <- as.numeric(parts[2])
  seconds <- as.numeric(parts[3])
  return(hours + minutes/60 + seconds/3600)
}

# Convert Time column from H:MM:SS format to decimal hours
df$Time <- sapply(df$Time, convert_time_to_hours)
time <- df$Time

# Get well column names (all columns except 'Time')
all_wells <- setdiff(names(df), 'Time')

# Filter to only wells B-G, columns 2-5 and 7-10
rows_to_include <- c('B', 'C', 'D', 'E', 'F', 'G')
cols_to_include <- c(2, 3, 4, 5, 7, 8, 9, 10)

well_columns <- c()
for (row in rows_to_include) {
  for (col in cols_to_include) {
    well_name <- paste0(row, col)
    if (well_name %in% all_wells) {
      well_columns <- c(well_columns, well_name)
    }
  }
}

cat("Analyzing", length(well_columns), "wells:", paste(well_columns, collapse = ", "), "\n")

# Convert all well columns to numeric
for (col in well_columns) {
  df[[col]] <- as.numeric(as.character(df[[col]]))
}

cat("Time range:", min(time), "to", max(time), "hours\n")

# Initialize results dataframe
results <- data.frame(
  Well = character(),
  Max_Growth = numeric(),
  Time_to_10pct = numeric(),
  stringsAsFactors = FALSE
)

# List to store plots
plot_list <- list()
```

```{r}
# Analyze each well
for (well in well_columns) {
  od_data <- df[[well]]
  
  tryCatch({
    # Check if there's actual growth in this well
    growth_range <- max(od_data, na.rm = TRUE) - min(od_data, na.rm = TRUE)
    
    if (growth_range < 0.01) {
      stop(paste("Insufficient growth detected (range =", round(growth_range, 4), ")"))
    }
    
    # Use LOESS smoothing to create a smooth version of the data
    # span controls how smooth (0.1 = less smooth, follows data closely; 0.5 = more smooth)
    loess_fit <- loess(od_data ~ time, span = 0.3)
    
    # Generate smoothed curve
    time_fine <- seq(min(time), max(time), length.out = 500)
    od_smooth <- predict(loess_fit, newdata = time_fine)
    
    # Find maximum growth from smoothed curve
    K <- max(od_smooth, na.rm = TRUE)
    
    # Find the initial OD
    od_init <- od_smooth[1]
    # Set variable for OD of a media only measurement
    
    
    # Calculate 5% of max growth

    threshold <- (K-od_init)*0.05 + od_init
   
    
    # Find time point where growth reaches 5%
    idx_5pct <- which(od_smooth >= threshold)[1]
    if (!is.na(idx_5pct)) {
      time_5pct <- time_fine[idx_5pct]
    } else {
      time_5pct <- NA
    }
    
    # Store results
    results <- rbind(results, data.frame(
      Well = well,
      Max_Growth = K,
      Time_to_5pct = time_5pct
    ))
    
    # Create plot data
    plot_data <- data.frame(Time = time, OD = od_data)
    smooth_data <- data.frame(Time = time_fine, OD = od_smooth)

    # Create plot
    p <- ggplot() +
      geom_point(data = plot_data, aes(x = Time, y = OD), alpha = 0.7, size = 2) +
      geom_line(data = smooth_data, aes(x = Time, y = OD), color = 'red', size = 0.7) +
      labs(title = paste0(well, '\nMax: ', round(K, 3), ', t(10%): ', round(time_10pct, 2), 'h'),
           x = 'Time (hours)', y = 'OD') +
      theme_bw()
    
    # Add 5% threshold lines if applicable
    if (!is.na(time_10pct)) {
      p <- p + 
        geom_hline(yintercept = threshold, linetype = 'dashed', color = 'green', alpha = 0.7) +
        geom_vline(xintercept = time_5pct, linetype = 'dashed', color = 'green', alpha = 0.7)# +
        #geom_point(aes(x = time_5pct, y = threshold), color = 'green', size = 3)
    }
    
    plot_list[[well]] <- p
    
  }, error = function(e) {
    message(paste("Could not analyze well", well, ":", e$message))
    results <<- rbind(results, data.frame(
      Well = well,
      Max_Growth = NA,
      Time_to_10pct = NA
    ))
  })
}

# Arrange plots in grid
n_plots <- length(plot_list)
n_cols <- 4
n_rows <- ceiling(n_plots / n_cols)

# For large numbers of wells (like 96-well plates), save as PDF instead
# PDF doesn't have the same size restrictions as PNG
pdf('growth_curves_5percent_fitted.pdf', width = 16, height = 4 * n_rows)
do.call(grid.arrange, c(plot_list, ncol = n_cols))
dev.off()


# Sort results by well name
results <- results %>% arrange(Well)

# Print results
cat("\n", rep("=", 70), "\n", sep = "")
cat("GROWTH CURVE 5percent ANALYSIS RESULTS\n")
cat(rep("=", 70), "\n", sep = "")
print(results, row.names = FALSE)
cat(rep("=", 70), "\n", sep = "")

# Save results to CSV
write.csv(results, 'growth_analysis_results5percent.csv', row.names = FALSE)
cat("\nResults saved to 'growth_analysis_results5percent.csv'\n")
```
This code will graph 5% to Max

```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
library(gridExtra)

# Load the results from the growth curve analysis
results <- read.csv('growth_analysis_results5percent.csv', stringsAsFactors = FALSE)

# Extract row letter and column number from well names
results$Row <- substr(results$Well, 1, 1)
results$Column <- as.numeric(substr(results$Well, 2, nchar(results$Well)))

# Assign species based on column number
results$Species <- ifelse(results$Column %in% c(2, 3, 4, 5), "Species 1", "Species 2")

# Assign time point based on row
results$TimePoint <- case_when(
  results$Row == "B" ~ 6,
  results$Row == "C" ~ 4,
  results$Row == "D" ~ 3,
  results$Row == "E" ~ 2,
  results$Row == "F" ~ 1,
  results$Row == "G" ~ 0.5,
  TRUE ~ NA_real_
)

# Calculate mean for each species at each time point
summary_stats <- results %>%
  group_by(Species, TimePoint) %>%
  summarise(
    Mean_MaxGrowth = mean(Max_Growth, na.rm = TRUE),
    Mean_Time5pct = mean(Time_to_5pct, na.rm = TRUE),
    .groups = 'drop'
  )

# Create separate datasets for each species
species1_data <- results %>% filter(Species == "Species 1")
species2_data <- results %>% filter(Species == "Species 2")
species1_summary <- summary_stats %>% filter(Species == "Species 1")
species2_summary <- summary_stats %>% filter(Species == "Species 2")

# Bar graphs for Maximum Growth - Species 1
p1_species1 <- ggplot() +
  geom_bar(data = species1_summary, aes(x = factor(TimePoint), y = Mean_MaxGrowth),
           stat = "identity", fill = "steelblue", alpha = 0.7, width = 0.6) +
  geom_point(data = species1_data, aes(x = factor(TimePoint), y = Max_Growth),
             size = 3, position = position_jitter(width = 0.1, seed = 42)) +
  labs(title = "Species 1 - Maximum Growth",
       x = "Time Point (hours)",
       y = "Maximum Growth (OD)") +
  theme_bw() +
  theme(text = element_text(size = 12))

# Bar graphs for Maximum Growth - Species 2
p1_species2 <- ggplot() +
  geom_bar(data = species2_summary, aes(x = factor(TimePoint), y = Mean_MaxGrowth),
           stat = "identity", fill = "coral", alpha = 0.7, width = 0.6) +
  geom_point(data = species2_data, aes(x = factor(TimePoint), y = Max_Growth),
             size = 3, position = position_jitter(width = 0.1, seed = 42)) +
  labs(title = "Species 2 - Maximum Growth",
       x = "Time Point (hours)",
       y = "Maximum Growth (OD)") +
  theme_bw() +
  theme(text = element_text(size = 12))

# Bar graphs for Time to 5% - Species 1
p2_species1 <- ggplot() +
  geom_bar(data = species1_summary, aes(x = factor(TimePoint), y = Mean_Time5pct),
           stat = "identity", fill = "steelblue", alpha = 0.7, width = 0.6) +
  geom_point(data = species1_data, aes(x = factor(TimePoint), y = Time_to_5pct),
             size = 3, position = position_jitter(width = 0.1, seed = 42)) +
  labs(title = "K. lactis - Time to 5% Max",
       x = "Time Point (hours)",
       y = "Time to 5% Max (hours)") +
  theme_bw() +
  theme(text = element_text(size = 12))

# Bar graphs for Time to 5% - Species 2
p2_species2 <- ggplot() +
  geom_bar(data = species2_summary, aes(x = factor(TimePoint), y = Mean_Time5pct),
           stat = "identity", fill = "coral", alpha = 0.7, width = 0.6) +
  geom_point(data = species2_data, aes(x = factor(TimePoint), y = Time_to_5pct),
             size = 3, position = position_jitter(width = 0.1, seed = 42)) +
  labs(title = "C. albicans - Time to 5% Max",
       x = "Time Point (hours)",
       y = "Time to 5% Max (hours)") +
  theme_bw() +
  theme(text = element_text(size = 12))

# Display plots side by side
grid.arrange(p1_species1, p1_species2, ncol = 2)
grid.arrange(p2_species1, p2_species2, ncol = 2)

# Save combined plots
png("max_growth_comparison.png", width = 14, height = 6, units = "in", res = 300)
grid.arrange(p1_species1, p1_species2, ncol = 2)
dev.off()

png("time_to_5pctklca.png", width = 14, height = 6, units = "in", res = 300)
grid.arrange(p2_species1, p2_species2, ncol = 2)
dev.off()

# Print summary statistics
cat("\n=== SUMMARY STATISTICS ===\n")
print(summary_stats)

# Save summary statistics
write.csv(summary_stats, 'species_summary_stats.csv', row.names = FALSE)
cat("\nSummary statistics saved to 'species_summary_stats.csv'\n")
cat("Plots saved as 'max_growth_comparison.png' and 'time_5pctklca_comparison.png'\n")
```

